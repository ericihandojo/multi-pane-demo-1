// This component represents the right pane of the application, which displays tabs with user information in a tree structure.
// It allows users to open multiple tabs, each showing details of a user in a nested tree format.
// It also provides functionality to close tabs and manage the visibility of the right pane.

import { Component, Input, OnChanges, OnInit, SimpleChanges } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatTabsModule } from '@angular/material/tabs';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatTreeModule } from '@angular/material/tree';
import { NestedTreeControl } from '@angular/cdk/tree';
import { MatTreeNestedDataSource } from '@angular/material/tree';
import { BehaviorSubject } from 'rxjs';

interface User {
  firstName: string;
  lastName: string;
  address: string;
  email: string;
  phone: string;
}

// For each user, we’ll create a node with children
interface TreeNode {
  name: string;
  children?: TreeNode[];
}

@Component({
  selector: 'app-right-pane',
  standalone: true,
  imports: [
    CommonModule,
    MatTabsModule,
    MatIconModule,
    MatButtonModule,
    MatTreeModule
  ],
  template: `
    <div class="right-container" *ngIf="visible">
      <mat-tab-group animationDuration="0ms" [(selectedIndex)]="selectedTabIndex">
        <mat-tab *ngFor="let tab of tabs; let i = index">
          <ng-template mat-tab-label>
            {{ tab.label }}
            <button mat-icon-button (click)="closeTab(i)" class="close-btn">
              <mat-icon>close</mat-icon>
            </button>
          </ng-template>

          <!-- Tree view inside each tab -->
          <mat-tree [dataSource]="tab.dataSource" [treeControl]="tab.treeControl">
            <!-- Parent node -->
            <mat-tree-node *matTreeNodeDef="let node; when: hasChildren" class="node-parent">
              <button mat-icon-button matTreeNodeToggle>
                <mat-icon>
                  {{ tab.treeControl.isExpanded(node) ? 'expand_more' : 'chevron_right' }}
                </mat-icon>
              </button>
              {{ node.name }}
            </mat-tree-node>
            <!-- Leaf node -->
            <mat-tree-node *matTreeNodeDef="let node; when: isLeaf" class="node-leaf">
              <button mat-icon-button disabled></button>
              {{ node.name }}
            </mat-tree-node>
          </mat-tree>
        </mat-tab>
      </mat-tab-group>
    </div>
  `,
  styles: [`
    .right-container {
      height: 100%;
      overflow-y: auto;
      background-color: #f5f5f5;
      display: flex;
      flex-direction: column;
    }
    mat-tab-group {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    mat-tab-group .mat-tab-body-wrapper {
      flex: 1;
      overflow: auto;
    }
    .node-parent, .node-leaf {
      display: flex;
      align-items: center;
      height: 32px;
    }
    .close-btn {
      margin-left: 8px;
      vertical-align: middle;
      width: 24px;
      height: 24px;
      line-height: 24px;
      min-width: 24px;
    }
    /* New styles for a thin border around each tab label */
    ::ng-deep .mat-tab-group .mat-tab-label {
      border: 2px solid;
      border-radius: 12px;
      margin: 4px;
      padding: 4px 12px;
      box-shadow: 0 0 4px rgba(0,0,0,0.3);
    }

    /* Different border colors for different submenus */
    ::ng-deep .mat-tab-group .mat-tab-label[label*="submenu1"] {
      border-color: #ff5722; /* Orange for submenu1 */
    }

    ::ng-deep .mat-tab-group .mat-tab-label[label*="submenu2"] {
      border-color: #2196f3; /* Blue for submenu2 */
    }

    ::ng-deep .mat-tab-group .mat-tab-label[label*="submenu3"] {
      border-color: #4caf50; /* Green for submenu3 */
    }

    /* Style for selected tab */
    ::ng-deep .mat-tab-group .mat-tab-label-active {
      background-color: rgba(0,0,0,0.04);
      font-weight: 500;
    }
  `]
})
export class RightPaneComponent implements OnInit {
  /** Whether this pane should be visible or hidden */
  @Input() visible: boolean = true;

  /** Whenever a submenu is clicked in the center, AppComponent will push the submenu name here */
  @Input() newTabLabel$!: BehaviorSubject<string | null>;

  // New input to receive the user list from the center pane.
  @Input() users: User[] = [];

  tabs: {
    label: string;
    treeControl: NestedTreeControl<TreeNode>;
    dataSource: MatTreeNestedDataSource<TreeNode>;
  }[] = [];

  selectedTabIndex = 0;

  ngOnInit() {
    // Subscribe to newTabLabel$ to add tabs whenever a submenu is selected
    this.newTabLabel$.subscribe(label => {
      if (label) {
        this.addTab(label);
      }
    });
  }

  addTab(label: string) {
    // Build TreeNodes from a static in-memory user list
    // In a real app, you'd pass the actual user list from CenterPaneComponent via an @Input.
    // Here, for demo, we assume a static array. We will override it later in AppComponent.

    // But actually, we want the RightPane to reflect the same user list that CenterPane manages.
    // So, instead of building it internally, AppComponent will pass a BehaviorSubject<User[]>.
    // For simplicity here, we'll suppose we have a static list. We’ll override in AppComponent injection.
  
    const nodes: TreeNode[] = this.users.map(user => ({
      name: user.lastName,
      children: [
        { name: `First Name: ${user.firstName}` },
        { name: `Address: ${user.address}` },
        { name: `Email: ${user.email}` },
        { name: `Phone: ${user.phone}` }
      ]
    }));

    const treeControl = new NestedTreeControl<TreeNode>(node => node.children || []);
    const dataSource = new MatTreeNestedDataSource<TreeNode>();
    dataSource.data = nodes;

    this.tabs.push({ label, treeControl, dataSource });
    this.selectedTabIndex = this.tabs.length - 1;
  }

  hasChildren = (_: number, node: TreeNode) =>
    !!node.children && node.children.length > 0;
  isLeaf = (_: number, node: TreeNode) =>
    !node.children || node.children.length === 0;

  closeTab(index: number) {
    this.tabs.splice(index, 1);
    if (this.selectedTabIndex >= this.tabs.length) {
      this.selectedTabIndex = this.tabs.length - 1;
    }
  }
}
